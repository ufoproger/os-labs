/*
Программа для иллюстрации работы двух потоков. Каждый поток увеличивает на 1 разделяемую переменную
a. */
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

int a = 0;

/*
Переменная a является глобальной статической для всей программы, поэтому она будет разделяться обеими
потоками.
*/
/*
Ниже следует текст функции, которая будет ассоциирована со 2-м потоком
*/
void *mythread(void *dummy)
/*
Параметр dummy в нашей функции не используется и присутствует только для совместимости типов данных.
По той же причине функция возвращает значение void *, хотя это никак не используется в программе.
*/
{
	pthread_t mythid; /* Для идентификатора потока */
	/*
	Заметим, что переменная mythid является динамической локальной переменной функции mythread(), т.е. поме-
	щается в стеке и, следовательно, не разделяется потоками.
	*/
	/*
	Запрашиваем идентификатор потока
	*/
	mythid = pthread_self();

	++a;

	printf("Thread %lu, Calculation result = %d\n", mythid, a);

	return NULL;
}

/*
Функция main() - она же ассоциированная функция главного потока
2*/
int main()
{
	pthread_t thid, mythid;
	int result;
	/*
	Пытаемся создать новый поток, ассоциированный с функцией mythread(). Передаем ему в качестве параметра
	значение NULL. В случае удачи в переменную thid занесется идентификатор нового потока. Если возникнет
	ошибка - прекратим работу.
	*/
	result = pthread_create( &thid, (pthread_attr_t *)NULL, mythread, NULL);

	if(result != 0) {
		printf ("Error on thread create, return value = %d\n", result);
		exit(-1);
	}
	
	printf("Thread created, thid = %lu\n", thid);
	/*
	Запрашиваем идентификатор главного потока
	*/
	mythid = pthread_self();
	++a;
	
	printf("Thread %lu, Calculation result = %d\n", mythid, a);
	/*
	Ожидаем завершения порожденного потока, не интересуясь какое значение он нам вернет. Если не выполнить
	вызов этой функции, то возможна ситуация, когда мы завершим функцию main() до того, как выполнится по-
	рожденный поток, что автоматически повлечет его завершение, исказив результаты.
	*/
	pthread_join(thid, (void **)NULL);

	return 0;
}